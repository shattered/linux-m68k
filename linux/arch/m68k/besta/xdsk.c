/*
 * besta/xdsk.c -- Low level SCSI driver for HCPU30 board.
 *
 * Copyright 1996, 1997	    Dmitry K. Butskoy
 *			    <buc@citadel.stu.neva.ru>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2, or (at your option) any
 * later version.
 *
 */

#include <linux/blkdev.h>
#include <linux/locks.h>
#include <linux/config.h>
#include <linux/errno.h>
#include <linux/signal.h>
#include <linux/sched.h>
#include <linux/timer.h>
#include <linux/fs.h>
#include <linux/kernel.h>
#include <linux/genhd.h>
#include <linux/delay.h>
#include <linux/config.h>
#include <linux/mm.h>
#include <linux/malloc.h>

#include <asm/setup.h>
#include <asm/pgtable.h>
#include <asm/system.h>
#include <asm/segment.h>

#include "besta.h"
#include "hcpu30.h"
#include "scsi.h"


#define XDSK0_MAJOR     40
#define XDSK1_MAJOR     41
#define XDSK2_MAJOR     42
#define XDSK3_MAJOR     43
#define XDSK4_MAJOR     44
#define XDSK5_MAJOR     45
#define XDSK6_MAJOR     46
#define XDSK7_MAJOR     47

struct xdsk {
	unsigned char    x0;
	unsigned char    x1;
	unsigned short   x2;
	void            *x4;
	long             x8;
	unsigned char    xc[12];
	char             r[8];
};

#define MAX_DEV         5       /* Max number of real  */

struct scsi_info_struct xdsk_info[MAX_DEV] = { {0, }, };


static int do_xdsk_cmd (int board, int target, char cmd[], int rw,
						    void *addr, int len);
static int xdskicmd (int board, int target, char cmd[], int rw,
				void *addr, int len, int timeout);
static void xdsk_intr (int vec, void *data, struct pt_regs *fp);

static void do_xdsk_request (int board, int target, int major);
static void end_request (int uptodate, int board, int target, int major);


void xdsk_init (void) {
	volatile struct xdsk *v = (struct xdsk *) XDSK_ADDR;
	struct scsi_info_struct *scsi_info = xdsk_info;
	int vector, level;
	int target, j;
	unsigned int type;
	char *inquiry_buffer;

	v->x2 = 7;
	v->x0 = 7;
	while ((signed char) v->x0 > 0) ;

	if (!besta_get_vect_lev ("xscsi", &vector, &level)) {
		vector = get_unused_vector();
		level = XDSK_LEV;
	}

	*((volatile char *) (X_ADDR + 0x7)) = vector;
	*((volatile char *) (X_ADDR + 0x6)) = level;

	printk ("Probing SCSI devices:\n");

	inquiry_buffer = (char *) kmalloc (256, GFP_KERNEL);
	if (!inquiry_buffer)  panic ("cannot kmalloc inquiry buffer\n");

	for (target = 0; target < MAX_DEV; target++, v++) {
	    int res;

	    /*  May be it is better to use static initialization for this one,
	       but  struct fields order may be changed later etc...
	    */
	    scsi_info[target].type = TYPE_NONE;
	    scsi_info[target].lun = 0;  /* No lun, no, no ...   */
	    scsi_info[target].state = STATE_FREE;   /*  To avoid bad ints  */
	    scsi_info[target].major =
		((unsigned char []) {
			XDSK0_MAJOR, XDSK1_MAJOR, XDSK2_MAJOR, XDSK3_MAJOR,
			XDSK4_MAJOR, XDSK5_MAJOR, XDSK6_MAJOR, XDSK7_MAJOR
		 } )[target];
	    scsi_info[target].name =
		((char * []) { "xdsk0", "xdsk1", "xdsk2", "xdsk3",
			       "xdsk4", "xdsk5", "xdsk6", "xdsk7" } )[target];
	    scsi_info[target].do_cmd_wait = xdskicmd;
	    scsi_info[target].do_cmd = do_xdsk_cmd;
	    scsi_info[target].do_request = do_xdsk_request;
	    scsi_info[target].end_request = end_request;


	    res = xdskicmd (0, target, scsi_test_unit_ready, 0, 0, 0, 0);

	    if (res == TRY_FOR_SENSE) {
		int key;

		res = xdskicmd (0, target, scsi_request_sense, 0,
					    (void *) 0xff028030, 16, 0);
		if (res)  continue;

		key = ((char *) 0xffff8030)[2] & 0xf;

		if (key != NOT_READY && key != UNIT_ATTENTION)  continue;

		scsi_info[target].state = STATE_NOT_READY;
	    }

	    if (xdskicmd (0, target, scsi_inquiry, 0, inquiry_buffer, 255, 0))
		    continue;

	    printk ("    %d: ", target);
	    for (j = 8; j < inquiry_buffer[4] + 5 && j < 255; j++)
		if (inquiry_buffer[j] >= ' ')
		    printk ("%c", inquiry_buffer[j]);
		else
		    printk (" ");
	    printk (", ");

	    type = inquiry_buffer[0] & 0x1f;
	    if (type > FIRST_UNKNOWN_TYPE)  type = FIRST_UNKNOWN_TYPE;

	    printk ("%s ", scsi_inits[type].name);

	    scsi_info[target].type = type;
	    (*scsi_inits[type].init) (target, inquiry_buffer, scsi_info);

	    switch (scsi_info[target].blksize) {
		case 1024:  v->x1 = 0;  break;
		case 512:   v->x1 = 1;  break;
		case 256:   v->x1 = 2;  break;
		default:    /*  error should be generated by init routine  */
	    }

	    if (scsi_info[target].type != TYPE_NONE)
		    /*  set  `major -- target & controller' dependence   */
		    scsi_targets[scsi_info[target].major] =
					     target + (num_scsi << 3);
	    else
		scsi_targets[scsi_info[target].major] = -1;


	    printk ("\n");

	} /*  for( ... ) */


	kfree (inquiry_buffer);

	printk ("done\n");

	scsi_infos[num_scsi] = scsi_info;
	num_scsi++;     /*  count xdsk as scsi controller   */

	besta_handlers[vector] = xdsk_intr;
	besta_intr_data[vector] = NULL;

	return;
}


static void xdsk_intr (int vec, void *data, struct pt_regs *fp) {
	volatile struct xdsk *v = (struct xdsk *) XDSK_ADDR;
	struct scsi_info_struct *scsi_info = xdsk_info;
	int target, err;

	for (target = 0; target < MAX_DEV; target++, v++) {

	    if ((signed char) v->x0 >= 0) continue;

	    if (scsi_info[target].state == STATE_FREE) {
		v->x0 = 0;
		printk("%s: interrupt while inactive\n", name(target));
		continue;
	    }

	    err = 0;

	    if (scsi_info[target].req_sense) {

		if (v->x0 != 128) {
		    scsi_info[target].req_sense = 0;
		    printk ("%s: Bad regsense (status = 0x%02x)\n",
						    name(target), v->x0);
		    err = CTL_ERROR;
		} else
		    clear_data_cache (&scsi_info[target].sense_buf,
					sizeof (scsi_info[target].sense_buf));

	    } else {

		switch (v->x0) {
		    case 128:   /*  OK   */
			break;
		    case 192:
			printk ("%s: Illegal Command\n", name(target));
			err = CTL_ILL_CMD;
			break;
		    case 193:
			printk ("%s: Illegal Length\n", name(target));
			err = CTL_ILL_PARAM;
			break;
		    case 195:
			printk ("%s: Timeout\n", name(target));
			err = CTL_TIMEOUT;
			break;
		    case 194:
			memcpy ((void *) v->xc, scsi_request_sense, 6);
			v->x2 = sizeof (scsi_info[target].sense_buf);
			v->x4 = scsi_info[target].sense_buf;
			v->x0 = 67;
			scsi_info[target].req_sense = 1;
			continue;
			break;

		    default:
			printk ("%s: Unknown error\n", name(target));
			err = CTL_ERROR;
			break;
		}
	    }

	    if (!scsi_info[target].inthandler) {
		    v->x0 = 0;
		    printk("%s: interrupt from unused target\n", name(target));
		    scsi_info[target].state = STATE_FREE;   /* avoid other  */
		    continue;
	    }

	    v->x0 = 0;
	    scsi_info[target].inthandler (target, err, scsi_info);

	} /* for( ... )   */

	return;
}


static int xdskicmd (int board, int target, char cmd[], int rw,
				void *addr, int len, int timeout) {
	volatile struct xdsk *v = ((struct xdsk *) XDSK_ADDR) + target;
	unsigned char c;
	int limit;

	memcpy ((void *) v->xc, cmd, 12);

	v->x8 = -1;
	v->x4 = addr;
	v->x2 = len;

	if (rw == 0)  v->x0 = 3;
	else  v->x0 = 4;

	if (timeout <= 0)
	    while ((signed char) (c = v->x0) > 0) ;
	else {
	    limit = jiffies + timeout;
	    while ((signed char) (c = v->x0) > 0 && jiffies < limit) ;
	    if (jiffies >= limit) {
		v->x0 = 0;      /*  really we should reset hear, but how???  */

		return SOFT_TIMEOUT;
	    }
	}

	v->x0 = 0;

	if (c != 128) {
	    switch (c & 0xf) {
		case 0:  return CTL_ILL_CMD;  break;
		case 1:  return CTL_ILL_PARAM;  break;
		case 2:  return TRY_FOR_SENSE;  break;
		case 3:  return CTL_TIMEOUT;  break;
		default: return CTL_ERROR;  break;
	    }
	}

	if (addr && rw == 0)  clear_data_cache (addr, len);

	return 0;
}


static int do_xdsk_cmd (int board, int target, char cmd[], int rw,
						    void *addr, int len) {
	volatile struct xdsk *v = ((struct xdsk *) XDSK_ADDR) + target;
	struct scsi_info_struct *scsi_info = xdsk_info;
	unsigned short flags;

	save_flags (flags);
	cli();

	while (scsi_info[target].state != STATE_FREE)
	       sleep_on (&scsi_info[target].wait);

	scsi_info[target].state = STATE_CMD;


	memcpy ((void *) v->xc, cmd, 14);
	v->x8 = -1;
	v->x4 = addr;
	v->x2 = len;

	if (rw == 0)  v->x0 = 67;
	else  v->x0 = 68;

	sleep_on (&scsi_info[target].wait);

	restore_flags (flags);

	if (rw == 0 && addr != NULL)  clear_data_cache (addr, len);

	return scsi_info[target].cmd_ret;
}


static void do_xdsk_request (int board, int target, int major) {
	volatile struct xdsk *v;
	struct scsi_info_struct *scsi_info = xdsk_info;
	int dev;
	struct buffer_head *bh;
	struct request *curr;
	struct hd_struct *part;

repeat:
	curr = blk_dev[major].current_request;

	if (!curr || curr->rq_status == RQ_INACTIVE)  return;

	if (MAJOR (curr->rq_dev) != major) {
	    panic ("%s: (major=%d) request list destroyed !\n",
						name(target), major);
	}

	bh = curr->bh;
	if(bh && !buffer_locked(bh)) {
	    panic ("%s: (major=%d) block not locked !\n", name(target), major);
	}

	dev = MINOR (curr->rq_dev);
	part = disk_info(target).part + dev;
	if (dev >= MAX_PARTS ||
	    curr->sector + curr->nr_sectors > 2 * part->nr_sects
	) {
	    end_request (0, 0, target, major);
	    goto repeat;
	}

	if (scsi_info[target].state != STATE_FREE)  return;

	v = ((struct xdsk *) XDSK_ADDR) + target;

	v->x2 = curr->current_nr_sectors << 9;  /* in bytes  */
	v->x4 = curr->buffer;
	if (v->x1)
	    v->x8 = ((curr->sector + 2 * part->start_sect) << v->x1) >> 1;
	else
	    v->x8 = (curr->sector >> 1) + part->start_sect;
	scsi_info[target].state = STATE_IO;

	if (curr->cmd == WRITE)  v->x0 = 66;
	else if (curr->cmd == READ)  v->x0 = 65;
	else panic ("%s: unknown command", name(target));

	return;
}


#define SECTOR_MASK (blksize_size[major] &&     \
	blksize_size[major][MINOR(curr->rq_dev)] ? \
	((blksize_size[major][MINOR(curr->rq_dev)] >> 9) - 1) :  \
	((BLOCK_SIZE >> 9)  -  1))

static void end_request (int uptodate, int board, int target, int major) {
	struct request *curr = blk_dev[major].current_request;
	struct buffer_head *bh;

	if (!uptodate) {
	    printk("end_request: I/O error, dev %04lX, sector %lu\n",
			(unsigned long) curr->rq_dev, curr->sector >> 1);

	    curr->nr_sectors--;
	    curr->nr_sectors &= ~SECTOR_MASK;
	    curr->sector += (BLOCK_SIZE/512);
	    curr->sector &= ~SECTOR_MASK;
	}
	else if (curr->cmd == READ)
		/*  because `curr->buffer' area was fulled by DMA   */
		clear_data_cache (curr->buffer, curr->current_nr_sectors << 9);

	if (!curr->bh && curr->nr_sectors > 0)  return;  /*  yet not ready   */

	curr->errors = 0;

	if((bh=curr->bh) != NULL) {

	    curr->bh = bh->b_reqnext;
	    bh->b_reqnext = NULL;

	    mark_buffer_uptodate(bh, uptodate);
	    unlock_buffer (bh);

	    if ((bh = curr->bh) != NULL) {
		curr->current_nr_sectors = bh->b_size >> 9;
		if (curr->nr_sectors < curr->current_nr_sectors) {
		    curr->nr_sectors = curr->current_nr_sectors;
		    printk ("end_request: buffer list destroyed\n");
		}
		curr->buffer = bh->b_data;
		return;
	    }
	}

	blk_dev[major].current_request = curr->next;
	if (curr->sem != NULL)
		up (curr->sem);
	curr->rq_status = RQ_INACTIVE;

	wake_up (&wait_for_request);

	return;
}


